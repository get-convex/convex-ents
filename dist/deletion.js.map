{"version":3,"sources":["../src/deletion.ts","../src/shared.ts"],"sourcesContent":["import {\n  FunctionReference,\n  GenericMutationCtx,\n  IndexRangeBuilder,\n  RegisteredMutation,\n  internalMutationGeneric as internalMutation,\n  makeFunctionReference,\n} from \"convex/server\";\nimport { GenericId, Infer, convexToJson, v } from \"convex/values\";\nimport { GenericEntsDataModel } from \"./schema\";\nimport { getEdgeDefinitions } from \"./shared\";\n\nexport type ScheduledDeleteFuncRef = FunctionReference<\n  \"mutation\",\n  \"internal\",\n  {\n    origin: Origin;\n    stack: Stack;\n    inProgress: boolean;\n  },\n  void\n>;\n\ntype Origin = {\n  id: string;\n  table: string;\n  deletionTime: number;\n};\n\nconst vApproach = v.union(v.literal(\"cascade\"), v.literal(\"paginate\"));\n\ntype Approach = Infer<typeof vApproach>;\n\nexport function scheduledDeleteFactory<\n  EntsDataModel extends GenericEntsDataModel,\n>(\n  entDefinitions: EntsDataModel,\n  options?: {\n    scheduledDelete: ScheduledDeleteFuncRef;\n  },\n): RegisteredMutation<\n  \"internal\",\n  { origin: Origin; stack: Stack; inProgress: boolean },\n  Promise<void>\n> {\n  const selfRef =\n    options?.scheduledDelete ??\n    (makeFunctionReference(\n      \"functions:scheduledDelete\",\n    ) as unknown as ScheduledDeleteFuncRef);\n  return internalMutation({\n    args: {\n      origin: v.object({\n        id: v.string(),\n        table: v.string(),\n        deletionTime: v.number(),\n      }),\n      stack: v.array(\n        v.union(\n          v.object({\n            id: v.string(),\n            table: v.string(),\n            edges: v.array(\n              v.object({\n                approach: vApproach,\n                table: v.string(),\n                indexName: v.string(),\n              }),\n            ),\n          }),\n          v.object({\n            approach: vApproach,\n            cursor: v.union(v.string(), v.null()),\n            table: v.string(),\n            indexName: v.string(),\n            fieldValue: v.any(),\n          }),\n        ),\n      ),\n      inProgress: v.boolean(),\n    },\n    handler: async (ctx, { origin, stack, inProgress }) => {\n      const originId = ctx.db.normalizeId(origin.table, origin.id);\n      if (originId === null) {\n        throw new Error(`Invalid ID \"${origin.id}\" for table ${origin.table}`);\n      }\n      // Check that we still want to delete\n      // Note: Doesn't support scheduled deletion starting with system table\n      const doc = await ctx.db.get(originId);\n      if (doc.deletionTime !== origin.deletionTime) {\n        if (inProgress) {\n          console.error(\n            `[Ents] Already in-progress scheduled deletion for \"${origin.id}\" was canceled!`,\n          );\n        } else {\n          console.log(\n            `[Ents] Scheduled deletion for \"${origin.id}\" was canceled`,\n          );\n        }\n        return;\n      }\n      await progressScheduledDeletion(\n        { ctx, entDefinitions, selfRef, origin },\n        newCounter(),\n        inProgress\n          ? stack\n          : [\n              {\n                id: originId,\n                table: origin.table,\n                edges: getEdgeArgs(entDefinitions, origin.table),\n              },\n            ],\n      );\n    },\n  });\n}\n\n// Heuristic:\n// Ent at the end of an edge\n//  has soft or scheduled deletion behavior && has cascading edges: schedule individually\n//  has cascading edges: paginate by 1\n//  else: paginate by decent number\nfunction getEdgeArgs(entDefinitions: GenericEntsDataModel, table: string) {\n  const edges = getEdgeDefinitions(entDefinitions, table);\n  return Object.values(edges).flatMap((edgeDefinition) => {\n    if (\n      (edgeDefinition.cardinality === \"single\" &&\n        edgeDefinition.type === \"ref\") ||\n      (edgeDefinition.cardinality === \"multiple\" &&\n        edgeDefinition.type === \"field\")\n    ) {\n      const table = edgeDefinition.to;\n      const targetEdges = getEdgeDefinitions(entDefinitions, table);\n      const hasCascadingEdges = Object.values(targetEdges).some(\n        (edgeDefinition) =>\n          (edgeDefinition.cardinality === \"single\" &&\n            edgeDefinition.type === \"ref\") ||\n          edgeDefinition.cardinality === \"multiple\",\n      );\n      const approach = hasCascadingEdges ? \"cascade\" : \"paginate\";\n\n      const indexName = edgeDefinition.ref;\n      return [{ table, indexName, approach } as const];\n    } else if (edgeDefinition.cardinality === \"multiple\") {\n      const table = edgeDefinition.table;\n      return [\n        {\n          table,\n          indexName: edgeDefinition.field,\n          approach: \"paginate\",\n        } as const,\n        ...(edgeDefinition.symmetric\n          ? [\n              {\n                table,\n                indexName: edgeDefinition.ref,\n                approach: \"paginate\",\n              } as const,\n            ]\n          : []),\n      ];\n    } else {\n      return [];\n    }\n  });\n}\n\ntype PaginationArgs = {\n  approach: Approach;\n  table: string;\n  cursor: string | null;\n  indexName: string;\n  fieldValue: any;\n};\n\ntype EdgeArgs = {\n  approach: Approach;\n  table: string;\n  indexName: string;\n};\n\ntype Stack = (\n  | { id: string; table: string; edges: EdgeArgs[] }\n  | PaginationArgs\n)[];\n\ntype CascadeCtx = {\n  ctx: GenericMutationCtx<any>;\n  entDefinitions: GenericEntsDataModel;\n  selfRef: ScheduledDeleteFuncRef;\n  origin: Origin;\n};\n\nasync function progressScheduledDeletion(\n  cascade: CascadeCtx,\n  counter: Counter,\n  stack: Stack,\n) {\n  const { ctx } = cascade;\n  const last = stack[stack.length - 1];\n\n  if (\"id\" in last) {\n    const edgeArgs = last.edges[0];\n    if (edgeArgs === undefined) {\n      await ctx.db.delete(last.id as GenericId<any>);\n      if (stack.length > 1) {\n        await continueOrSchedule(cascade, counter, stack.slice(0, -1));\n      }\n    } else {\n      const updated = { ...last, edges: last.edges.slice(1) };\n      await paginateOrCascade(\n        cascade,\n        counter,\n        stack.slice(0, -1).concat(updated),\n        {\n          cursor: null,\n          fieldValue: last.id,\n          ...edgeArgs,\n        },\n      );\n    }\n  } else {\n    await paginateOrCascade(cascade, counter, stack, last);\n  }\n}\n\nconst MAXIMUM_DOCUMENTS_READ = 8192 / 4;\nconst MAXIMUM_BYTES_READ = 2 ** 18;\n\nasync function paginateOrCascade(\n  cascade: CascadeCtx,\n  counter: Counter,\n  stack: Stack,\n  { table, approach, indexName, fieldValue, cursor }: PaginationArgs,\n) {\n  const { ctx, entDefinitions } = cascade;\n  const { page, continueCursor, isDone, bytesRead } = await paginate(\n    ctx,\n    { table, indexName, fieldValue },\n    {\n      cursor,\n      ...limitsBasedOnCounter(\n        counter,\n        approach === \"paginate\"\n          ? { numItems: MAXIMUM_DOCUMENTS_READ }\n          : { numItems: 1 },\n      ),\n    },\n  );\n\n  const updatedCounter = incrementCounter(counter, page.length, bytesRead);\n  const updated = {\n    approach,\n    table,\n    cursor: continueCursor,\n    indexName,\n    fieldValue,\n  };\n  const relevantStack = cursor === null ? stack : stack.slice(0, -1);\n  const updatedStack =\n    isDone && (approach === \"paginate\" || page.length === 0)\n      ? relevantStack\n      : relevantStack.concat(\n          approach === \"cascade\"\n            ? [\n                updated,\n                {\n                  id: page[0]._id,\n                  table,\n                  edges: getEdgeArgs(entDefinitions, table),\n                },\n              ]\n            : [updated],\n        );\n  if (approach === \"paginate\") {\n    await Promise.all(page.map((doc) => ctx.db.delete(doc._id)));\n  }\n  await continueOrSchedule(cascade, updatedCounter, updatedStack);\n}\n\nasync function continueOrSchedule(\n  cascade: CascadeCtx,\n  counter: Counter,\n  stack: Stack,\n) {\n  if (shouldSchedule(counter)) {\n    const { ctx, selfRef, origin } = cascade;\n    await ctx.scheduler.runAfter(0, selfRef, {\n      origin,\n      stack,\n      inProgress: true,\n    });\n  } else {\n    await progressScheduledDeletion(cascade, counter, stack);\n  }\n}\n\ntype Counter = {\n  numDocuments: number;\n  numBytesRead: number;\n};\n\nfunction newCounter() {\n  return {\n    numDocuments: 0,\n    numBytesRead: 0,\n  };\n}\n\nfunction incrementCounter(\n  counter: Counter,\n  numDocuments: number,\n  numBytesRead: number,\n) {\n  return {\n    numDocuments: counter.numDocuments + numDocuments,\n    numBytesRead: counter.numBytesRead + numBytesRead,\n  };\n}\n\nfunction limitsBasedOnCounter(\n  counter: Counter,\n  { numItems }: { numItems: number },\n) {\n  return {\n    numItems: Math.max(1, numItems - counter.numDocuments),\n    maximumBytesRead: Math.max(1, MAXIMUM_BYTES_READ - counter.numBytesRead),\n  };\n}\n\nfunction shouldSchedule(counter: Counter) {\n  return (\n    counter.numDocuments >= MAXIMUM_DOCUMENTS_READ ||\n    counter.numBytesRead >= MAXIMUM_BYTES_READ\n  );\n}\n\nasync function paginate(\n  ctx: GenericMutationCtx<any>,\n  {\n    table,\n    indexName,\n    fieldValue,\n  }: { table: string; indexName: string; fieldValue: any },\n  {\n    cursor,\n    numItems,\n    maximumBytesRead,\n  }: {\n    cursor: string | null;\n    numItems: number;\n    maximumBytesRead: number;\n  },\n) {\n  const query = ctx.db\n    .query(table)\n    .withIndex(indexName, (q) =>\n      (q.eq(indexName, fieldValue) as IndexRangeBuilder<any, any, any>).gt(\n        \"_creationTime\",\n        cursor === null ? cursor : +cursor,\n      ),\n    );\n\n  let bytesRead = 0;\n  const results = [];\n  let isDone = true;\n\n  for await (const doc of query) {\n    if (results.length >= numItems) {\n      isDone = false;\n      break;\n    }\n    const size = JSON.stringify(convexToJson(doc)).length * 8;\n\n    results.push(doc);\n    bytesRead += size;\n\n    // Check this after we read the doc, since reading it already\n    // happened anyway, and to make sure we return at least one\n    // result.\n    if (bytesRead > maximumBytesRead) {\n      isDone = false;\n      break;\n    }\n  }\n  return {\n    page: results,\n    continueCursor:\n      results.length === 0\n        ? cursor\n        : \"\" + results[results.length - 1]._creationTime,\n    isDone,\n    bytesRead,\n  };\n}\n","import {\n  DocumentByName,\n  FieldTypeFromFieldPath,\n  SystemDataModel,\n  TableNamesInDataModel,\n} from \"convex/server\";\nimport { EdgeConfig, GenericEdgeConfig, GenericEntsDataModel } from \"./schema\";\n\nexport type EntsSystemDataModel = {\n  [key in keyof SystemDataModel]: SystemDataModel[key] & {\n    edges: Record<string, never>;\n  };\n};\n\nexport type PromiseEdgeResult<\n  EdgeConfig extends GenericEdgeConfig,\n  MultipleRef,\n  MultipleField,\n  SingleOptional,\n  Single,\n> = EdgeConfig[\"cardinality\"] extends \"multiple\"\n  ? EdgeConfig[\"type\"] extends \"ref\"\n    ? MultipleRef\n    : MultipleField\n  : EdgeConfig[\"type\"] extends \"ref\"\n    ? SingleOptional\n    : EdgeConfig[\"optional\"] extends true\n      ? SingleOptional\n      : Single;\n\nexport type IndexFieldTypesForEq<\n  EntsDataModel extends GenericEntsDataModel,\n  Table extends TableNamesInDataModel<EntsDataModel>,\n  T extends string[],\n> = Pop<{\n  [K in keyof T]: FieldTypeFromFieldPath<\n    DocumentByName<EntsDataModel, Table>,\n    T[K]\n  >;\n}>;\n\ntype Pop<T extends any[]> = T extends [...infer Rest, infer _Last]\n  ? Rest\n  : never;\n\nexport function getEdgeDefinitions<\n  EntsDataModel extends GenericEntsDataModel,\n  Table extends TableNamesInDataModel<EntsDataModel>,\n>(entDefinitions: EntsDataModel, table: Table) {\n  return entDefinitions[table].edges as Record<\n    keyof EntsDataModel[Table][\"edges\"],\n    EdgeConfig\n  >;\n}\n"],"mappings":"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","names":["internalMutation","table","edgeDefinition"]}